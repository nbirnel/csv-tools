#!/usr/bin/perl
use strict;
use vars qw($opt_h $opt_u $opt_8);
use warnings;
use Getopt::Std;
use Text::CSV;

my (@requests);
my (%header);
my (%filler);

my $lines = 0;
my $csvin  = Text::CSV->new ({ binary => 1, eol => $/ });
my $csvout = Text::CSV->new ({ binary => 1, eol => $/, always_quote =>1 });
my $utf8 = '';

getopts('h');
if ($opt_h) { &help(0); }
if ($opt_8) { $utf8 = ':encoding(utf8)'; }

@requests = &cook($ARGV[0]);
shift;

my $stdout;
open $stdout, ">-$utf8" or die "Can't open standard out: $!";

@ARGV = ("-") unless @ARGV;
while (@ARGV) {
    my $fh;
    $ARGV= shift @ARGV;
    if ($ARGV eq '-') {
        $fh = *STDIN;
        open $fh, "<-$utf8" or die "Can't open standard in: $!";
    } else {
        open $fh, "<$utf8", $ARGV or die "Can't open $ARGV: $!";
    }
    my $file_lines = 0;

    LINE: while (my $row = $csvin->getline ( $fh )) {
        $lines++;
        $file_lines++;
        my @input = @$row;
        my @output;

        my $ref_output = \@output;
        my $field;
        my $i = 0;
        foreach my $keeper (@requests) {
            if ($lines == 1) {
                if (exists $header{$i}) {
                    $output[$i] = $header{$i};
                } elsif ($keeper == 0) {
                    $output[$i] = '';
                } else { 
                    $output[$i] = $input[$keeper - 1]; 
                }
            } elsif (exists $filler{$i}) {
                    $output[$i] = $filler{$i};
            } elsif ($keeper == 0) { 
                $output[$i] = ''; 
            } else { 
                $output[$i] = $input[$keeper - 1];
            }

            $i++;
        }
        my $status = $csvout->print ($stdout, $ref_output);
        unless ($status) {
            warn "LINE: $lines - $file_lines of $ARGV\t wrote incorrectly\n";
        }
    }
}

sub cook {
    my @raw = split /,/, shift;
    my (@cooked);
    foreach my $range (@raw) {
        if ($range =~ /^\d+$/) { push @cooked, $range; }
        elsif ($range =~ /^(\d+)-(\d+)$/) { push @cooked, ($1..$2); }
        elsif ($range =~ /^(\d+):([^:]+):?$/) { 
            push @cooked, $1;
            $header{$#cooked} = $2;
        }
        elsif ($range =~ /^(\d+):([^:]+):([^:]+)$/) { 
            push @cooked, $1;
            $header{$#cooked} = $2;
            $filler{$#cooked} = $3;
        }
        elsif ($range =~ /^(\d+)::([^:]+)$/) { 
            push @cooked, $1;
            $filler{$#cooked} = $2;
        }
        else { die "bad field name or range $range" ; }
    }
    return @cooked;
}

sub help {
    my $status = shift;
    while (<DATA>) { print; }
    exit $status;
}

__END__

USAGE
ccut [-u] f1,f2,f3... [FILE]
OPTIONS
f1,f2,f3...    Process fields f1,f2,f3... etc
               f1 etc may be ranges, eg: 3,6-9,15,2
               0 is a special blank field
               Numbers may be given with override header and filler
               like so:
               N:header:filler
               N:header:
               N::filler

-h  Display help and exit. 
-u  Use unix line endings for input and output

EXAMPLES
  ccut 4,3 ORDERS.csv > NEWORDERS.csv
Put the fourth and then third column of ORDERS in NEWORDERS.

SEE ALSO
chead
cjoin
csort
cval

BUGS
Don't use this with Strawberry Perl. If you are on Windows,
use Cygwin Perl. (Not tested with ActiveState Perl.)

Fields are numbered from 1 on the command line, but internally
are represented from 0.

Assumes all csvs use /r/n as EOL.

TODO
Check our arguments better - is the field list all numbers?
Does the file exist? Did we receive garbage flags?
