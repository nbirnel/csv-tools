#!/usr/bin/perl
use strict;
use warnings;
use vars qw($opt_h $opt_i $opt_8);
use Getopt::Std;
use Text::CSV;

my (@requests);

my $inverse = 0;
my @input;
my $csvin  = Text::CSV->new ({ binary => 1, eol => $/ });
my $utf8 = '';

getopts('hi8');
if ($opt_h) { &help(0); }
if ($opt_i) { $inverse=1; }
if ($opt_8) { $utf8 = ':encoding(utf8)'; }

while (scalar(@ARGV) > 1) {
    push @requests, (shift @ARGV);
}

my $stdout;
open $stdout, ">-$utf8" or die "Can't open standard out: $!";

@ARGV = ("-") unless @ARGV;
while (@ARGV) {
    my $fh;
    $ARGV= shift @ARGV;
    if ($ARGV eq '-') {
        $fh = *STDIN;
        open $fh, "<-$utf8" or die "Can't open standard in: $!";
    } else {
        open $fh, "<$utf8", $ARGV or die "Can't open $ARGV: $!";
    }
    my $file_lines = 0;

    LINE: while (my $row = $csvin->getline ( $fh )) {
        @input = @$row;
        if    ($inverse)  { &printinverse(); }
        elsif (@requests) { &printrequests(); }
        else {
            my $i = 0;
            foreach my $field (@input) {
                printf("%3d: %s\n", ++$i, $field);
            }
        }
        last LINE;
    }
}

sub printinverse() {
    my $notfirst;
    my $i = 0;
    IFIELD: foreach my $field (@input) {
        $i++;
        foreach my $request (@requests) {
            if ($request eq $field) { next IFIELD; }
        }
        if ($notfirst) { printf ','; }
        printf('%d', $i);
        $notfirst = 1;
    }
}

sub printrequests() {
    #FIXME This is essentially the last function inside-out. refactor?
    my $notfirst;
    foreach my $request (@requests) {
        if ($notfirst) { printf ',' }
        my $i = 0;
        FIELD: foreach my $field (@input) {
            $i++;
            if ($request eq $field) {
                printf('%d', $i);
                last FIELD;
            } 
        }
        $notfirst = 1;
    }
}

sub help {
    my $status = shift;
    while (<DATA>) { print; }
    exit $status;
}

__END__

chead - display field headers for a csv file

USAGE
chead FILE
chead {FIELD} {FIELD}... {FILE}
chead -i {FIELD} {FIELD}... {FILE}
chead -h

In the first form, chead will display all field headers, numbered one
per line, for FILE.

In the second form, chead will output the matching field headers as
a comma-separated list of numbers, suitable for use as a flag for ccut.

The third form is the inverse of the second form - it outputs the 
field headers that do not match.

OPTIONS 
-h  Display help and exit. 
-i  Invert the matching of field headers.
-8  Force utf-8 encoding of input

EXAMPLES

SEE ALSO
ccut
cval

BUGS
Don't use this with Strawberry Perl. If you are on Windows,
use Cygwin Perl. (Not tested with ActiveState Perl.)

Fields are numbered from 1 on the command line, but internally
are represented from 0.

TODO
Does the file exist? Did we receive garbage flags?
