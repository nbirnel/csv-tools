#!/usr/bin/perl
use strict;
use warnings;
use vars qw($opt_j $opt_a $opt_s $opt_1 $opt_2 $opt_h $opt_o $opt_8);
use Getopt::Std;
use Text::CSV;

my ($allf, $joinfd1, $joinfd2, @tests); 
my $skip = 0;
my $csv1  = Text::CSV->new ({ binary => 1, eol => $/ });
my $csv2  = Text::CSV->new ({ binary => 1, eol => $/ });
my $csvout = Text::CSV->new ({ binary => 1, eol => $/, always_quote =>1 });
my $utf8 = '';
my $outf;


getopts('ha:s:1:2:j:o:8');
if ($opt_h) { &help(0); }

if ($opt_s) { $skip = $opt_s; }
if ($opt_a) { $allf = $opt_a; }
if ($opt_o) { $outf = $opt_o; }
if ($opt_1) { $joinfd1 = $opt_1 -1; }
if ($opt_2) { $joinfd2 = $opt_2 -1; }
if ($opt_j) { $joinfd1 = $joinfd2 = $opt_j -1; }
if ($opt_8) { $utf8 = ':encoding(utf8)'; }

die "$0: I expect two filenames as arguments\n" unless @ARGV == 2;
die "$0: both files cannot be standard input\n"
  if $ARGV[0] eq '-' and $ARGV[1] eq '-';

my @file_names = map { $_ eq '-' ? 'STDIN' : $_ } @ARGV;

my $stdout;
open $stdout, ">-$utf8" or die "Can't open standard out: $!\n";

if (defined $allf) {
    if ($allf == 1) { $allf = $file1; }
    elsif ($allf == 2) { $allf = $file2; }
    else { die("option -a takes 1 or 2"); }
}

&get_field_specs($outf);

open(F1, $ARGV[0]) || die "Can't read $file_names[0]: $!\n";
open(F2, $ARGV[1]) || die "Can't read $file_names[1]: $!\n";

my @buf1; # line buffers for the two files
my @buf2; #

get_a_line(\@buf1, \*F1);
get_a_line(\@buf2, \*F2);

my ($diff, $eof1, $eof2);
while (@buf1 && @buf2) {

while (@buf1 && @buf2) {

    $diff = ($buf1[0]->[$j1]||'') cmp ($buf2[0]->[$j2]||'');
    if ($diff < 0) {
            print_joined_lines($buf1[0], []) if $unpairables[0];
            shift @buf1;
            get_a_line(\@buf1, \*F1) || shift @buf1;
            next;
    }
    if ($diff > 0) {
            print_joined_lines([], $buf2[0]) if $unpairables[1];
            shift @buf2;
            get_a_line(\@buf2, \*F2) || shift @buf2;
            next;
    }

    $eof1 = 0;
    do {
            get_a_line(\@buf1, \*F1) || $eof1++
    } until $eof1 || ($buf1[-1]->[$j1] cmp $buf2[0]->[$j2]);

    $eof2 = 0;
    do {
            get_a_line(\@buf2, \*F2) || $eof2++
    } until $eof2 || ($buf1[0]->[$j1] cmp $buf2[-1]->[$j2]);

    if ($print_pairables) {
            for (my $left = 0; $left < @buf1 - 1; $left++) {
        for (my $right = 0; $right < @buf2 - 1; $right++) {
	print_joined_lines($buf1[$left], $buf2[$right]);
        }
            }
    }
    
    if ($eof1) { @buf1 = () }
    else       { splice @buf1, 0, @buf1 - 1 }

    if ($eof2) { @buf2 = () }
    else       { splice @buf2, 0, @buf2 - 1 }
}

if ($unpairables[0] && @buf1) {
    do{
            print_joined_lines(shift @buf1, [])
    } until !get_a_line(\@buf1, \*F1);
}
if ($unpairables[1] && @buf2) {
    do{
            print_joined_lines([], shift @buf2)
    } until !get_a_line(\@buf2, \*F2);
}

close F1 || die "Can't close $file_names[0]: $1\n";
close F2 || die "Can't close $file_names[1]: $1\n";

exit 0;

sub get_a_line {
    my ($aref, $fh) = @_;
    my $not_eof = defined(my $row = $csvin->getline ( <$fh> ));
    if ($not_eof) { push (@$aref, @$row) }
    else { push @$aref, undef }
    return $not_eof;
}

sub print_joined_lines {
    my ($line1, $line2) = @_;
    my @out;
    my $ref_out = \@out;
    if (@fields) {
        my ($line, $file, $field);
        foreach my $f (@fields) {
            ($file, $field) = @$f;
            if ($file == 0) {  # POSIX: 0 means join field
	            ($line, $field) = @$line1 ? ($line1, $j1) : ($line2, $j2);
            } else {
	            $line = $file == 1 ? $line1 : $line2;
            }
            push @out, defined $line->[$field] ? $line->[$field] : $e_string;
        }
    } else {
        unless (@$line1) { ($line1,$line2) = ($line2,$line1) }
        for my $i ($j1, 0..$j1-1, $j1+1..@$line1-1) {
            push @out, defined $line1->[$i] ? $line1->[$i] : $e_string
        }
        for my $i (0..$j2-1, $j2+1..@$line2-1) {
            push @out, defined $line2->[$i] ? $line2->[$i] : $e_string
        }
    }
    my $status = $csvout->print ($stdout, $ref_output);
    unless ($status) {
        warn "LINE: $lines - $file_lines of $ARGV\t wrote incorrectly\n";
    }
}

sub get_field_specs {
    my $text = shift @_;
    my @specs = split /\s+|,/, $text;
    foreach my $spec (@specs) {
        $spec =~ /^(0)$|^([12])\.(\d+)$/ || die "$0: weird field spec `$spec'\n";
        if (defined $1) { push @fields, [0, -1]; }
        else {
            die "$0: fields start at 1\n" if $3 == 0;
            push @fields, [$2, $3 - 1];
        }
    }
}

